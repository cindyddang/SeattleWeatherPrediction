# -*- coding: utf-8 -*-
"""SVM_Seattles.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BRyTTHOZEWXx0QOmlgYSmpAYFJLNDeUM
"""

!pip install -q pandas numpy scikit-learn matplotlib

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, accuracy_score
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder, MinMaxScaler

# Load the dataset
!wget -q https://raw.githubusercontent.com/amankharwal/Website-data/master/seattle-weather.csv
df = pd.read_csv('seattle-weather.csv')

# Convert date column to datetime objects
df['date'] = pd.to_datetime(df['date'])
df = df.set_index('date')
label_encoder = LabelEncoder()
df['weather_encoded'] = label_encoder.fit_transform(df['weather'])

# Handle missing values (if any) in all columns
# Impute missing values using the mean for numerical features
for column in ['precipitation', 'temp_max', 'temp_min', 'wind']:
    df[column] = df[column].fillna(df[column].mean())  # Using assignment instead of inplace=True

# Impute missing values in the target variable with the mode
df['weather'] = df['weather'].fillna(df['weather'].mode()[0]) # Using assignment instead of inplace=True

# Normalize data
scaler = MinMaxScaler()
numerical_features = ['precipitation', 'temp_max', 'temp_min', 'wind']
df[numerical_features] = scaler.fit_transform(df[numerical_features])

sequence_length = 7  # Use past 7 days to predict the next day
features = numerical_features + ['weather_encoded']

# Create features for past n days
# For each sequence_length (in this case, I choose 7), it calculated the mean and std of each features
def create_features(df, sequence_length, features):
    feature_data = []
    for i in range(sequence_length, len(df)):
        past_data = df[features].iloc[i-sequence_length:i] # Get data from day i-7 to day i
        feature_row = past_data.mean().tolist() + past_data.std().tolist() # Calculate mean and std for those info
        feature_data.append(feature_row)
    return np.array(feature_data) # Return set of arrays of means and std so the model can look and predict the next day

# Prepare features
X = create_features(df, sequence_length, numerical_features)
y = df['weather_encoded'][sequence_length:].values

# Split data
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and train a classifier (e.g., Support Vector Machine)
model = SVC(kernel='linear')
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_val)

# Evaluate the model
accuracy = accuracy_score(y_val, y_pred)
print("Accuracy:", accuracy)

# Create and display the confusion matrix
cm = confusion_matrix(y_val, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=weather_mapping.keys()) # Use correct labels for display
disp.plot(cmap=plt.cm.Blues)
plt.title("Confusion Matrix")
plt.show()